# The Art of Clean Code

[Reference](https://www.oreilly.com/library/view/the-art-of/9781098141349/)

<aside>
🐸 **지나치게 복잡하면 변화할 수 없다**

</aside>

Project Based Learning 권장

## Complexity = 부분들로 이루어진 전체를 분석하고 이해하거나 설명하기 어려운 정도
    
    Project Lifecycle
    
    Plan → Define → Design → Build → Test → Deploy → Plan → …
    
    Plan
    
    End Users → Features they “needs”
    
    기능 구현 비용
    
    기대 가치
    
    영업 시사점
    
    유지보수성
    
    확장성
    
    법적 제한
    
    Define
    
    Plan Outputs → Software Requirements
    
    Design
    
    System Architecture
    
    Module, Components
    
    User Interface
    
    Build
    
    Software
    
    Test
    
    Unit Tests, TDD(?), …
    
    Deploy
    
    Continuous Deployment
    
    Software & Algorithm
    
    User Input ⬆️ → Issue ⬆️
    
    Bubblesort → Quicksort, Timsort
    
    Measurement
    
    Algorithmic complexity
    
    Cyclomatic complexity
    
    Cognitive complexity
    
    Knowledge Graph
    
    Process
    
    Daily Life
    
    Priority
    
    Deep Work
    
    [](https://product.kyobobook.co.kr/detail/S000000619577)
    
## 80:20
    
    다수의 결과가 소수의 원인에서 나온다
    
    - 소수의 코드가 대다수의 실행시간 차지 → vital few + trivial many
        
        사용자들이 가장 자주 실행하는20% code 반복적으로 최적화하여 더 빠르고 더 사용자 친화적인 컴퓨팅 환경 만들기
        
    - 가장 중요한 영역에서 전문 지식 쌓기 (+ 활동 최적화 → 성과 측정 → 활동 최적화 → …)
        - 핵심 소수에 집중하고 사소한 다수는 무시하면 생산성이 대폭 증가
        - 승자독식 → 하나의 분야라도 vital few가 되자, 그렇지 못하면 모든 분야에서 trivial many
            
            vital few에 초점을 맞추지 않으면 trivial many에 휩쓸린다
            
            [Net Worth Tracker - NetworthShare](https://www.networthshare.com/)
            
    - 실천
        - 당신의 성공 지표를 발견
        - 삶의 큰 목표를 설정
        - 더 적은 자원으로 같은 것을 달성하는 방법들을 찾기
        - 성공 경험, 실패 경험을 회고
        - 관심 분야에 관한 더 많은 책 읽기
        - 기존의 제품을 개선하고 향상하는데 시간 들이기
        - 웃어라
        - 가치를 줄이는 행위들 하지 말기
    - 80:20 = Fractal

## Minimum Vaiable Product (MVP)
    
    최소 기능 제품 = 필요한 기능들 외에는 모두 제거하고 빠르게 가설 검증
    
    ↔ Stealth Mode
    
    아이디어 보호 목적
    
    잠재적 사용자들로부터 어떤 피드백도 구하지 않고 프로젝트 끝까지 완료
    
    동기부여 상실 ← 의심
    
    주의분산
    
    잘못된 가정(예측)
    
    기한 넘김 ← 예측 가능성 낮음
    
    응답 부족 ← 침묵
    
    불필요한 복잡성 → 누적 비용, 어떤 부분 집합이 시장에서 통할까? 검증 어려움
    
    Rapid Prototyping
    
    제품 시장 적합도를 찾기 위해 조기에 자주 배포
    
    4 Axis
    
    Functionality : 명확하게 표현된 기능
    
    Design
    
    Reliability 모든 기능 철저하게 테스트 → 비신뢰성으로 인한 부정적인 사용자 피드백 최소화, 기능들에 대한 직접적인 피드백 최대화
    
    Usability 사용하기 쉽도록
    
    MVP ≠ 제공하는 가치도 낮고 사용성 떨어지고 성의없는 디자인 제공하는 제품
    
    MVP = 위대한 기능성, 디자인, 신뢰성, 사용성을 제공하는 고품질 제품
    
    장점
    
    가설을 저비용으로 테스트
    
    작업량 최소화
    
    개발자가 투자한 시간은 사용자들에게 더 많은 가치 제공
    
    미래 유지보수 비용 최소화
    
## 17 Principles
    
    Refactoring = 코드 기반을 개선하고 복잡성을 줄이는 과정
    
    1. 큰 그림을 생각하라 (Software Architecture)
        - 파일, 모듈들이 각각 모두 필요한가, 아니면 일부는 합쳐서 코드 간의 상호의존성을 줄일까
        - 코드를 일반화하여 라이브러리로 만들어 응용 프로그램의 메인 코드를 단순화할까
        - 라이브러리를 사용하여 코드의 라인 수를 줄일까
        - 동일한 결과를 중복 계산하지 않도록 캐시를 도입할까
            - 캐싱 전략
                - (오프라인으로) 사전에 계산들을 수행하고 수행된 결과들을 캐시에 저장
                - (오프라인으로) 입력받는 대로 계산들을 수행하고 그 결과물을 캐시에 저장
            - 캐시 교체 정책
                - FIFO
                - …
        - 기존 알고리즘과 동일한 결과를 내는 더 단순하고 적절한 알고리즘으로 교체할까
        - 도움이 되지 않는 성급한 최적화를 제거할까
        - 더 적합한 프로그래밍 언어를 도입할까
    2. 거인들의 어깨 위에 서라 (바퀴를 재발명하지 마라)
    3. 기계가 아닌 사람을 위한 코드
        
        “어떤 바보도 컴퓨터가 이해할 수 있는 코드를 작성할 수 있다. 좋은 프로그래머들은 사람이 이해할 수 있는 코드를 작성한다”
        
        코드 작업 시간
        
        대부분의 시간 동안 새로운 코드를 작성하기 위해 오래된 코드를 읽는다 
        
        읽기 : 작성 = 10 : 1
        
        ⇒ 읽기 쉬운 코드를 만들면 작업이 쉬워진다
        
    4. 올바른 이름을 사용하라
        - 서술적인 이름
        - 모호하지 않은 이름
        - 발음하기 쉬운 이름
        - 상수에 이름을 붙이고 매직 넘버를 사용하지 않기
    5. 표준을 지키고 일관성을 유지하라 (Style Guide, Linter)
    6. 주석을 사용하라
    7. 불필요한 주석들을 피하라
        - 인라인 주석을 사용하지 않기
        - 분명한 주석을 추가하지 않기
        - 옛날 코드를 주석 처리하지 않기
        - 문서화 기능 사용하기
    8. 놀람 최소화 원칙 (Principle of Least Surprise)
        
        대부분의 사용자들이 예상하는 대로 동작해야 한다
        
    9. 반복하지 않기 (DRY, Don’t Repeat Yourself)
    10. 단일 책임 원칙
        - 모든 함수는 한 개의 주요한 목적을 가져야 한다
        - 책임 = 변경해야 할 이유
    11. 테스트
        - 단위 테스트
        - 사용자 인수 테스트
        - 스모크 테스트
        - 성능 테스트
        - 확장성 테스트
    12. 작은 것이 아름답다
        - 동일 목표를 달성하기 위해 더 적은 라인 수로
        - 소수의 큰 코드 블록 → 다수의 작은 코드 블록
    13. 디미터의 법칙 (Law of Demeter)
        
        [What is Demeter?](https://www.khoury.northeastern.edu/home/lieber/what-is-demeter.html)
        
        코드 요소들의 상호 의존성 최소화
        
        객체/동작 정의 → 객체 정의 + 동작 정의
        
        오직 인접한 친구(Method)에게만 말해야 한다
        
        Method Chaining 비권장
        
    14. 지금이 아니라 미래에 사용할 코드는 구현하지 마라
        
        과도한 엔지니어링을 피하자
        
    15. 과도한 들여쓰기 (계층적 구조 : 조건문/함수 정의/반복문 등) 금지
    16. 지표를 사용하라 (NPath Complexity, Cyclomatic Complexity, …)
    17. 보이 스카웃 법칙과 리팩토링
        
        “야영장을 떠날 때는 들어올 때보다 깨끗하게 하라”
        
        만나는 모든 코드조각을 클린하게 만드는 습관 들이기
        
        [고무 오리 디버깅](https://ko.wikipedia.org/wiki/고무_오리_디버깅)
        
## Premature Optimization
    
    성급한 최적화
    
    작은 효율성에 성급하게 집중하지 말자
    
    최적화를 멈춰야 할 때를 알자
    
    - 몇 번만 실행되는 함수
    - 반드시 필요하지 않는 기능
    - 실제 사용자 수를 측정하고 확장성 최적화
    - 실험적인 코드에도 테스트 추가
    
    계획의 불완전함을 수용
    
    측정을 먼저, 개선은 다음 (기준점, benchmark)
    
## Flow
    
    몰입
    
    요소
    
    - Attention 깊은 집중과 완전한 초점
    - Action 현재 과업을 빠르고 효율적으로 진행
    - Self 덜 의식하고 내적 비판, 의심, 두려움을 접는다
    - Control 자신에 대해 덜 의식하는 만큼 현재 상황에 대한 높은 통제감
    - Time 시간이 흐르는 것도 망각
    - Reward 활동 자체를 원하기, 외적 보상이 없어도 몰입된 상태가 본질적으로 보상 그 자체
    
    Condition
    
    - 분명한 목표
        
        세부 활동이 형성하는 분명한 최종 목표
        
    - 피드백이 즉시 이루어짐
        
        바람직한 행동에 상, 그렇지 않은 행동에 벌
        
        Community Discussion, MVP, …
        
    - 기회와 능력의 균형
        
        도전은 실력에 비해 너무 어렵지도 쉽지도 않아야 함
        
        너무 어려움 → 불안, 공포
        
        너무 쉬움 → 지루함, 무관심
        
    
    Tips for Programmers
    
    - 항상 업무에서 실용적인 코드 프로젝트 진행
        
        집중되지 않은 학습의 상태로 시간 사용하지 말기
        
    - 당신의 목적을 달성하는 Fun 프로젝트 작업
    - 당신의 강점 기반으로 작업
    - 코딩하는 시간을 큰 단위로 잡기 (매일 1시간 → 3일에 한 번씩 3시간)
    - 몰입 시간 동안 주의 분산 제거 (SNS, …)
    - 반드시 해야 한다고 알고 있는 분명한 것들을 하자
        - 충분한 수면
        - 건강한 식사
        - 규칙적인 운동
    - 고품질의 정보를 소비하자
        
        “쓰레기가 들어가면 쓰레기가 나온다”
        
        얕은 블로그 기사 → 프로그래밍 책 → 상위 저널에서 발행된 연구 논문 등을 읽기
        
## Unix Philosophy
    
    Do One Thing And Do It Well (DOTADIW)
    
    한 개의 일을 잘하자
    
    쉽도록 단순하고 분명하고 정확하고 모듈화된 코드 작성하자
    
    그 후 작고 사소한 프로그램을 조합하여 더 복잡한 프로그램을 만들어내자
    
    한 개의 믿을 수 있고 효율적으로 해결하는 함수를 작성하는 것이 동시에 다수의 문제들을 해결하는 노력보다 낫다
    
    15 Principles
    
    1. 각 함수는 한 개의 일을 잘한다
    2. 단순함이 복잡함보다 좋다
    3. 작은 것이 아름답다 (복잡성 줄어듦, 유지보수성 개선됨, 테스트 가능성 개선됨)
        
        모듈화되고 재사용 가능한 코드 작성하기
        
    4. 프로토타입 가능한 빠르게 만들기
        
        빠르게 실패하고, 자주 실패하고, 앞으로 나아가며 실패하자
        
    5. 효율성보다는 이식성 선택
        
        효율성 ↔ 이식성
        
        VM
        
        이식성 ⬆️
        
        효율성 (런타임/메모리 효율성) ⬇️
        
        이식성 = 한 환경에서 다른 환경으로 이동했을 때 정상적으로 동작하는 능력
        
    6. 데이터는 플랫 텍스트 파일에 저장 (CSV, …)
        
        단, 확실하게 필요한 경우에는 최적화된 데이터 표현 사용
        
    7. 소프트웨어를 레버리지로 사용
        
        레버리지 = 작은 양의 에너지 사용하여 그 효과를 배가
        
        - 대중의 지혜
        - 컴퓨팅 파워
        
        [Home](https://pythononeliners.com/)
        
    8. 불필요한 Captive User Interface 피하기
        
        Captive User Interface = 프로그램의 주요 실행 흐름이 시작되기 전에 사용자 상호작용 요구
        
        ssh, top, vim, …
        
        → 코드의 사용성 제한 → 사용자 상호작용 + 주요 실행 흐름 분리
        
    9. 모든 프로그램을 필터로 만들기
        
        하나의 출력을 다른 프로그램의 입력으로 사용 가능하도록 설정
        
        Homogeneous Input/Output Mapping (Recommended)
        
        Input Type = Output Type
        
    10. 더 나쁜 것이 더 좋다
        
        더 적은 기능성을 갖는 코드를 개발하는 것이 보통 실제로 더 좋은 접근법
        
        자원이 제한적이라면
        
        배포 전에 끊임없이 더 좋게 만들려고 노력하는 것보다
        
        나쁜 제품을 배포하고 시장에서 최초가 되는 것이 좋음
        
        First-mover Advantage
        
    11. 클린 코드가 영리한 코드보다 좋다
        
        명확함이 영리함보다 낫다
        
        영리한 코드는 단순성을 희생해서는 안된다
        
    12. 다른 프로그램과 연결되는 프로그램 설계
    13. 코드를 견고하게 만들기
        
        변경을 철저하게 테스트하면 배포된 코드는 고장의 위험으로부터 보호받음
        
        검증받지 않으면 코드를 변경할 수 있도록 접근 권한 통제
        
        데이터를 정기적으로 백업
        
        분산 시스템을 사용하여 단일 장애점을 회피
        
        사용자의 악의적인 입력 예상하고 대비
        
    14. 실패는 빠르고 시끄럽게
        
        문제점들을 가능한 고치는 동안 고칠 수 없는 오류들을 숨기면 안됨
        
        오류는 축적되기 때무네 미리 오류를 알리는 것이 바람직
        
    15. 가능하다면 프로그램을 생성하는 프로그램 만들기
        
        고수준의 언어를 저수준의 언어로 튜닝하는 Hand Hacking 피하기
        
        자동으로 생성될 수 있는 코드는 그래야 한다
        
        반복 작업을 줄이자
        
## UI/UX Design
    
    Google Landing Page vs Naver Landing Page
    
    Material Design
    
    사용자의 시간(직관성)은 화면의 공간보다 훨씬 소중하다
    
    - 여백을 사용
    - 디자인 요소 제거 (매우 중요한 요소만 남기기)
    - 기능 제거 (매우 중요한 기능 위주로만 개선)
    - 폰트와 색상의 변화 줄이기 (1~2가지의 폰트/색상 권장)
    - 일관성 지키기